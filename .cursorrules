# ApeRAG Project - Cursor AI Rules

You are an expert full-stack developer working on ApeRAG, a Retrieval-Augmented Generation (RAG) system. Follow these rules when generating code and providing assistance.

## Project Overview
- **Backend**: Django REST Framework with Celery for async tasks
- **Frontend**: React with TypeScript
- **APIs**: OpenAPI/Swagger specification
- **Infrastructure**: Kubernetes (Helm), Docker
- **Databases**: PostgreSQL, MongoDB, Neo4j, Redis, Qdrant, Elasticsearch
- **Key Features**: Document parsing, embedding, vector search, LLM integration, graph knowledge

## Code Style & Standards

### General
- Use English for all code, comments, and documentation
- Follow PEP 8 for Python code
- Use TypeScript for all React components
- Maintain consistent naming conventions across the project
- Add comprehensive docstrings and type hints

### Python/Django Backend
- Use Django Ninja for API endpoints (not DRF)
- Use function-based views with @router decorators
- Implement proper Pydantic models for data validation in schema/view_models.py
- Follow Django project structure: apps, models, views, urls
- Use custom authentication system (GlobalAuth) supporting multiple auth methods
- Use Celery for long-running tasks (document processing, embedding generation)
- Implement proper error handling with custom exceptions
- Write database queries efficiently, avoid N+1 problems
- Use Django migrations for all database schema changes
- Use custom User model (aperag.User) extending AbstractUser

### React/TypeScript Frontend (UmiJS)
- Use functional components with hooks
- Implement proper TypeScript interfaces for all props and state
- Use UmiJS models for state management (not React Query)
- Follow UmiJS conventions and routing patterns
- Use dynamic routing with $paramName pattern
- Implement proper error boundaries
- Use consistent file naming: PascalCase for components, camelCase for utilities
- Support internationalization with locales/ directory
- Auto-generate API client from OpenAPI specs
- Use UmiJS plugins for antd, locale, and model integration

### API Design
- Follow RESTful principles
- Use OpenAPI 3.0 specification
- Implement proper HTTP status codes
- Use consistent response formats
- Include pagination for list endpoints
- Implement proper filtering and search capabilities
- Version APIs appropriately (/api/v1/)

### Database
- Use appropriate database for each use case:
  - PostgreSQL: Primary relational data
  - MongoDB: Document storage
  - Neo4j: Graph relationships
  - Redis: Caching and sessions
  - Qdrant: Vector embeddings
  - Elasticsearch: Full-text search
- Implement proper indexing strategies
- Use database transactions where appropriate
- Implement soft deletes for important data

### Infrastructure
- Use Docker for containerization with multi-stage builds
- Use docker-compose.yml for local development
- Use Helm charts for Kubernetes deployments in deploy/aperag/
- Implement proper health checks and readiness probes
- Use ConfigMaps and Secrets for configuration
- Support multiple registries (Docker Hub, Aliyun)
- Use Makefile for build automation and development workflows
- Implement proper logging and monitoring
- Support both local and multi-platform builds

## File Structure Patterns

### Backend Structure (Django App)
```
aperag/
├── api/                 # OpenAPI schemas and components
│   ├── components/      # OpenAPI schema components
│   └── paths/          # API endpoint definitions
├── auth/               # Authentication logic
├── chat/               # Chat functionality with SSE/WebSocket
│   ├── history/        # Chat history management
│   ├── sse/           # Server-Sent Events
│   └── websocket/     # WebSocket connections
├── context/            # Context management
├── db/                 # Database utilities
├── docparser/          # Document parsing
├── embed/              # Embedding generation
├── flow/               # Workflow management
│   ├── base/          # Base flow components
│   ├── examples/      # Example flows
│   ├── runners/       # Flow runners
│   └── tests/         # Flow tests
├── graph/              # Graph operations (Neo4j)
├── llm/                # LLM integration
├── objectstore/        # Object storage (MinIO/S3)
├── pipeline/           # Data processing pipelines
├── query/              # Query processing
├── rank/               # Ranking algorithms
├── schema/             # Data schemas and models
├── service/            # Business logic services
├── source/             # Data source integrations
│   ├── feishu/        # Feishu integration
│   └── tencent/       # Tencent services
├── tasks/              # Celery tasks
├── utils/              # Utility functions
│   ├── spider/        # Web scraping utilities
│   └── weixin/        # WeChat integration
├── vectorstore/        # Vector database operations
├── version/            # Version management
└── views/              # API views
```

### Frontend Structure (UmiJS + React)
```
frontend/src/
├── api/                # Auto-generated API client
│   ├── apis/          # API endpoint functions
│   └── models/        # TypeScript models
├── assets/             # Static assets
│   ├── bots/          # Bot-related assets
│   ├── collection_source/ # Collection source assets
│   ├── models/        # Model assets
│   └── page/          # Page assets
├── components/         # Reusable components
│   ├── check-card/    # Check card component
│   ├── page-header/   # Page header component
│   └── typing-animate/ # Typing animation component
├── constants/          # Constants and configs
├── layouts/            # Layout components
│   └── auth/          # Authentication layouts
├── locales/            # Internationalization
│   ├── en-US/         # English translations
│   └── zh-CN/         # Chinese translations
├── models/             # UmiJS models (state management)
├── pages/              # Page components
│   ├── accounts/      # Account management
│   ├── bots/          # Bot management
│   │   └── $botId/    # Dynamic bot pages
│   │     ├── chats/   # Chat interface
│   │     └── flow/    # Flow editor
│   ├── callback/      # OAuth callbacks
│   ├── collections/   # Collection management
│   │   └── $collectionId/ # Dynamic collection pages
│   └── settings/      # Settings pages
├── services/           # Business logic services
├── types/              # TypeScript interfaces
└── utils/              # Utility functions
```

### Infrastructure Structure
```
deploy/
├── aperag/             # Helm chart
│   └── templates/     # Kubernetes templates
└── databases/          # Database configurations
    ├── elasticsearch/ # Elasticsearch setup
    ├── mongodb/       # MongoDB setup
    ├── neo4j/         # Neo4j setup
    ├── postgresql/    # PostgreSQL setup
    ├── qdrant/        # Qdrant vector DB setup
    └── redis/         # Redis setup
```

## Specific Guidelines

### RAG Implementation
- Implement chunking strategies for different document types in docparser/
- Use appropriate embedding models for different content types in embed/
- Implement hybrid search (vector + keyword) using Qdrant and Elasticsearch
- Cache embeddings to avoid recomputation using Redis
- Implement proper retrieval ranking and reranking in rank/
- Support multiple data sources (Feishu, Tencent, WeChat) in source/
- Use flow/ for workflow management and pipeline orchestration
- Implement graph knowledge extraction using Neo4j in graph/

### Celery Tasks
- Define tasks in aperag/tasks/ directory
- Use descriptive task names following project conventions
- Implement proper retry logic with exponential backoff
- Use task routing for different queues (document processing, embedding, etc.)
- Implement progress tracking for long-running tasks
- Handle task failures gracefully with proper logging
- Use Celery Beat for scheduled tasks (celerybeat service)
- Support both worker and beat processes in deployment

### Security
- Validate all user inputs
- Implement proper CORS settings
- Use HTTPS in production
- Implement rate limiting
- Sanitize file uploads
- Use environment variables for sensitive data

### Performance
- Implement caching strategies (Redis)
- Use database connection pooling
- Optimize vector search queries
- Implement pagination for large datasets
- Use async/await for I/O operations

### Testing
- Write unit tests for critical functions in tests/unit_test/
- Implement integration tests for API endpoints
- Use pytest for Python testing
- Implement e2e tests in tests/e2e_test/
- Test document parsing, embedding, LLM, and ranking components
- Mock external services in tests
- Use test datasets in tests/e2e_test/evaluation/datasets/
- Frontend testing: Use UmiJS built-in testing capabilities

### Documentation
- Maintain OpenAPI documentation in aperag/api/
- Auto-generate frontend SDK from OpenAPI specs
- Document complex algorithms and business logic
- Include setup instructions in README with make commands
- Document environment variables and configuration
- Use docs/ directory for additional documentation
- Include debugging guides for PyCharm (docs/HOW-TO-DEBUG.md)

## Common Patterns

### Django Ninja API Structure
```python
# aperag/views/main.py
from ninja import Router
from aperag.views.utils import auth_middleware, get_user, success, fail

router = Router()

@router.get("/collections", auth=auth_middleware)
async def list_collections_view(request) -> view_models.CollectionList:
    user = get_user(request)
    result = await list_collections(user)
    return success(result)

@router.post("/collections")
async def create_collection_view(request, collection: view_models.CollectionCreate) -> view_models.Collection:
    user = get_user(request)
    result = await create_collection(user, collection)
    return success(result)
```

### Authentication System
```python
# Multiple auth methods supported via GlobalAuth
from aperag.auth.authentication import GlobalAuth

# In views, use auth_middleware for protected endpoints
@router.get("/protected-endpoint", auth=auth_middleware)
async def protected_view(request):
    user_id = GlobalAuth.get_user_id(request)
    auth_type = GlobalAuth.get_auth_type(request)  # 'admin', 'apikey', 'jwt', 'session'
    # ... endpoint logic
```

### Error Handling
```python
# Backend (Django Ninja)
from http import HTTPStatus
from aperag.views.utils import fail, success

try:
    result = process_document(file)
    return success(result)
except Exception as e:
    logger.error(f"Document processing failed: {e}")
    return fail(HTTPStatus.BAD_REQUEST, "Failed to process document")
```

```typescript
// Frontend (UmiJS)
import { request } from 'umi';

try {
  const response = await request('/api/v1/documents/upload', {
    method: 'POST',
    data: formData,
  });
  return response;
} catch (error) {
  console.error('Upload failed:', error);
  throw new Error('Failed to upload document');
}
```

### API Response Format
```python
# Success response using aperag.views.utils.success()
{
    "success": true,
    "data": {...},
    "message": "Operation completed successfully"
}

# Error response using aperag.views.utils.fail()
{
    "success": false,
    "message": "Error description",
    "code": 400
}

# Paginated response
{
    "success": true,
    "data": {
        "items": [...],
        "pageResult": {
            "page": 1,
            "limit": 20,
            "total": 100
        }
    }
}
```

### UmiJS Component Structure
```typescript
// UmiJS Page Component
import { useModel } from 'umi';
import { useIntl } from '@umijs/max';

interface ComponentProps {
  // Define props
}

const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  const intl = useIntl();
  const { data, loading } = useModel('modelName');
  
  return (
    <div>
      {/* Use intl for internationalization */}
      <h1>{intl.formatMessage({ id: 'page.title' })}</h1>
      {/* Component JSX */}
    </div>
  );
};

export default Component;
```

### UmiJS Model Structure
```typescript
// src/models/modelName.ts
import { useState, useCallback } from 'react';

export default function useModelName() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      // API call logic
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    data,
    loading,
    fetchData,
  };
}
```

## Development Workflow

### Make Commands
- `make install` - Install dependencies with uv
- `make dev` - Setup development environment with hooks
- `make run-backend` - Start Django backend
- `make run-frontend` - Start UmiJS frontend
- `make run-celery` - Start Celery worker
- `make run-db` - Start all database services
- `make format` - Format code with ruff
- `make lint` - Lint code
- `make test` - Run all tests
- `make generate-frontend-sdk` - Generate frontend API client

### Environment Setup
- Use `.env` file for backend configuration
- Use `frontend/.env` for frontend configuration
- Copy from template files: `envs/env.template` and `frontend/deploy/env.local.template`

## When Working on This Project
1. Always consider the RAG pipeline: ingestion → processing → embedding → storage → retrieval → generation
2. Think about scalability and performance implications
3. Consider multi-tenancy and user isolation
4. Use proper logging for debugging (structured logging)
5. Follow the existing code patterns and conventions
6. Test thoroughly before committing (unit + e2e tests)
7. Update documentation when adding new features
8. Use make commands for consistent development workflow
9. Generate frontend SDK after API changes
10. Support internationalization (zh-CN/en-US)

Remember: This is a production RAG system that needs to handle large documents, multiple users, and complex queries efficiently. The system supports multiple data sources, workflow orchestration, and graph knowledge extraction. 